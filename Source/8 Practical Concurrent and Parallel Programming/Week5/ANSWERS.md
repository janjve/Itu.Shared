Exercise 5.1
=============

5.1.1 - 5.1.3
-------------
```
# OS:   Windows 10; 10.0; amd64
# JVM:  Oracle Corporation; 1.8.0_74
# CPU:  Intel64 Family 6 Model 60 Stepping 3, GenuineIntel; 8 "cores"
# Date: 2016-09-30T10:23:15+0200
```
The results are plotted in the file jve_5.1.1-5.1.2.xlsx

5.1.4
-------------

The results are as expected. It should be noted that the results doesn't get worse by adding more tasks, 
which was the case when using threads. The executor will use as many cores as that are available for the jvm, 
whereas the implementation from last week will keep adding overhead and thereby slowing it down.

5.1.5
-------------

```
# OS:   Windows 10; 10.0; amd64
# JVM:  Oracle Corporation; 1.8.0_74
# CPU:  Intel64 Family 6 Model 60 Stepping 3, GenuineIntel; 8 "cores"
# Date: 2016-09-30T11:05:26+0200
```

#TODO: Add file.

The results are plotted in the file jve_5.1.5.xlsx.

It is not noticably faster using the LongAdder than our own implementation as it can be observed on the graph.

Exercise 5.3
=============

5.3.1
-------------

See Code

5.3.3
-------------

Measured runtime in sec.:
```
Retrieved in: 6.212030259
Retrieved in: 7.220270193
Retrieved in: 8.300353963
Retrieved in: 10.605866976
Retrieved in: 10.333536822
```

5.3.4
-------------

Measured runtime in sec.:
```
Retrieved in: 1.954890768
Retrieved in: 2.003220112
Retrieved in: 2.552612414
Retrieved in: 9.264647135
Retrieved in: 2.203419494
```

No matter how we parallelize the problem, it will never be faster than the time it takes to fetch the slowest responding web site. This is particularly noticable in the fourth run, where the runtime was as slow as some of the sequential.

Exercise 5.4
=============

5.4.1
-------------

Sanity check. See code.

5.4.2
-------------

See code for implementation.

5.4.3
-------------

See code for implementation.

The two Results are the same apart from 3 places. Two of them are autogenerated signatures, which are unique for each request.
The last is a link from jp.dk which links to an article. However running it multiple times shows that this isn't consistent, but just shows that the web pages are changing inbetween runs.

5.4.4
-------------

See code for implementation.

This works as expected.

5.4.5
-------------

See code for implementation.

Since we force the implementation to use a maximum of 3 threads we can at most run 3 runnables at a time.
The problem is that the runnables never terminates and we can therefor at most run pipelines of size 3 if we don't release the threads.

5.4.6
-------------

See code for implementation.

The order was the same before because it was run by a single thread in sequential, which means loading a page was never done before one that comes earlier in the url array. Now there are two threads consuming urls from the array and fetching webpages. There is no garanty that one thread won't finish two requests before the other finishes one. This scenario may of course cause overlap.